---
title: "BioDIGS_Announcement_Map"
author: "Katherine I. Cooper"
date: "2025-12-09"
output: html_document
---

## BioDIGS figure 1

#### Katherine Cooper \| Enke Lab \| James Madison University

------------------------------------------------------------------------

### Part A: The map

#### Data processing and cleaning

Load libraries

```{r}
packages <- c("readxl",
              "ggplot2",
              "maps",
              "mapdata",
              "dplyr",
              "stringr",
              "tidyr",
              "ggrepel",
              "sf",
              "cluster",
              "ggforce",
              "patchwork",
              "ggnewscale"
)

for (pkg in packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
  }
  library(pkg, character.only = TRUE)
}
```

Loading the data, manipulating, and cleaning.

```{r}
#Load BIODIGS data
BioDIGS_site_data <- read_excel("C:/Users/kathe/Downloads/BioDIGS_site_data.xlsx")

#Cleaning data--making the lat and long compatible with spatial mapping
BioDIGS_Cleaned <- BioDIGS_site_data %>% 
  mutate(
    longitude = as.numeric(gsub("[^0-9\\.-]", "", longitude)),
    latitude  = as.numeric(gsub("[^0-9\\.-]", "", latitude)),
    longitude = as.numeric(longitude),
    latitude = as.numeric(latitude),
    long_read = gsub("\\s*\\(planned\\)\\s*", "", BioDIGS_site_data$long_read), #remove planned
    long_read = trimws(long_read),
    mgmt_type_clean = ifelse(grepl("unmanaged", BioDIGS_site_data$`mgmt_type (managed vs unmanaged)`, ignore.case = TRUE),
                                            "Unmanaged",
                                            ifelse(grepl("managed", BioDIGS_site_data$`mgmt_type (managed vs unmanaged)`, ignore.case = TRUE),
                                                   "Managed",
                                                   NA)), #Seperate managed and unmanaged without extra terms
    across(where(is.character), ~na_if(., "NA")) #Change string NA to null values
  )
#Remove null values
BioDIGS_Cleaned <- BioDIGS_Cleaned %>%
  filter(!is.na(longitude) & !is.na(latitude))
```

Creating new variables for the site ID labels:

```{r}
#Set up for the looping 
Current_id="Null"

iteration=0

test_list <- list()

#Long convoluted loop to make the labels.
for (i in 1:nrow(BioDIGS_Cleaned)) {
  Id_value <- substr(BioDIGS_Cleaned$site_id[i], start = 1, nchar(BioDIGS_Cleaned$site_id[i]) - 2)
  if (Id_value == Current_id){
    iteration <- iteration + 1
    New_row <- data.frame(
      ID_Start = Id_value,
      Label = paste0(Id_value, "1-", Id_value, iteration),
      Number = iteration
    )
    test_list[[i]] <- New_row
  }
  else{
    iteration = 1
    Current_id = Id_value
    New_row <- data.frame(
        ID_Start = Id_value,
        Label = paste0(Id_value, iteration),
        Number = iteration
      )
      test_list[[i]] <- New_row
  }
}

final_id <- do.call(rbind, test_list)

#Sorting the new data frame by the max iteration 
final_id <- final_id %>%
  group_by(ID_Start) %>%
  slice_max(Number, with_ties = FALSE) %>%
  ungroup() %>%
  select(-Number)

#Joining the new label variable onto the cleaned data
BioDIGS_Cleaned <- BioDIGS_Cleaned %>% 
  mutate(ID_Start = substr(site_id, 1, nchar(site_id) - 2)) %>%
  left_join(final_id, by = "ID_Start") %>%
  select(-ID_Start)

#Cleaning the coding environment of unnecessary variables 
remove(final_id)
remove(test_list)
remove(New_row)
```

Making the labels the average coords nearby:

```{r}
GraphLabs <- BioDIGS_Cleaned %>% 
  group_by(Label) %>%
  summarise(
    latitude  = mean(latitude,  na.rm = TRUE),
    longitude = mean(longitude, na.rm = TRUE),
    .groups = "drop"
  )

head(GraphLabs)
```

Filtering the data based on the DMV (DC, MD, NoVa) area

```{r}
BioDIGS_filtered_DMV <- BioDIGS_Cleaned %>% 
  filter (
      longitude >= -78,
      longitude <= -76,
      latitude >= 38,
      latitude <= 40
  )
```

------------------------------------------------------------------------

#### Clustering for the bubbles

Clustering for the overall:

```{r}
set.seed(123)
coords <- BioDIGS_Cleaned[, c("longitude", "latitude")]
dist_matrix <- dist(coords)
clusters <- hclust(dist_matrix, method = "average")
BioDIGS_Cleaned$group <- cutree(clusters, h = 0.8)  
  
  
bubble_data <- BioDIGS_Cleaned %>%
  group_by(group, mgmt_type_clean) %>%
  summarise(
    size = n(),
    lon = mean(longitude),
    lat = mean(latitude),
    .groups = "drop"
  )
  
bubble_data <- bubble_data %>%
  mutate(
    offset = ifelse(mgmt_type_clean == "Managed", 0.01, -0.01),
    lon_offset = lon + offset,
    lat_offset = lat + offset  
  )
bubble_data <- na.omit(bubble_data)

bubble_data <- st_as_sf(bubble_data_DMV, coords = c("lon", "lat"), crs = 4326)

#Cleaning the environment. 
remove("coords")
remove("dist_matrix")
remove("clusters")
```

Clustering for the DMV area:

```{r}
set.seed(123)
coords <- BioDIGS_filtered_DMV[, c("longitude", "latitude")]
dist_matrix <- dist(coords)
clusters <- hclust(dist_matrix, method = "average")
BioDIGS_filtered_DMV$group <- cutree(clusters, h = 0.1)  


bubble_data_DMV <- BioDIGS_filtered_DMV %>%
  group_by(group, mgmt_type_clean) %>%
  summarise(
    size = n(),
    lon = mean(longitude),
    lat = mean(latitude),
    .groups = "drop"
  )

bubble_data_DMV <- bubble_data_DMV %>%
  mutate(
    offset = ifelse(mgmt_type_clean == "Managed", 0.01, -0.01),
    lon_offset = lon + offset,
    lat_offset = lat + offset
  )
bubble_data_DMV <- na.omit(bubble_data_DMV)

#Cleaning the environment.
remove("coords")
remove("dist_matrix")
remove("clusters")

```

------------------------------------------------------------------------

#### Graphing set-up

National Lakes Assessment aggregated ecoregions. I could not get the EPA ecoregions to work again on a proper scale. Canada would distort the United States if I removed it.

```{r}

data(stateMapEnv)
US_map <- map_data("state")

Biome_data <- st_read("C:/Users/kathe/Downloads/Aggr_Ecoregions_2015")

Converted_Biomes <- st_transform(Biome_data, crs = 4326)

#Makinhg a standardized colorscheme. Semi-coolorblind friendly. 
cols <- c(
  "Temperate Plains"      = "#7d9953",
  "Northern Appalachians" = "#48608C",
  "Northern Plains"       = "#90B6C3",
  "Southern Appalachians" = "#7A9EB0",
  "Coastal Plains"        = "#C2D39B",
  "Upper Midwest"         = "#596E42",
  "Western Mountains"     = "#7D8FA0",
  "Southern Plains"       = "#C6A877",
  "Xeric"                 = "#E8C48C"
)

#Basic plot with no data on it
Map1<-ggplot(Converted_Biomes) +
  geom_sf(aes(fill=WSA9_NAME)) +
  theme_void() + scale_fill_manual(values = cols)
```

Adding the bubbles to the base map

```{r}
BubbleMap <- Map1 + 
  new_scale_fill()+
  geom_point(
  data = bubble_data,
  aes(x = lon_offset, y = lat_offset, size = size, shape = mgmt_type_clean, color = mgmt_type_clean),
  fill ="white",
  stroke=2
) +
  scale_size_continuous(range = c(3, 12)) +
  scale_color_manual(values = c("Managed" = "#6699ff", "Unmanaged" = "#fa3232")) +
  scale_fill_manual(values = alpha("white", 0.15)) + 
  scale_shape_manual(values = c("Managed" = 21, "Unmanaged" = 25)) +
  theme_void()+
  theme(legend.position="left",
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 9),
        legend.key.size = unit(0.4, "cm"))+
  labs(color="Management Type", size="Sample Count")+
 # guides(fill = guide_legend(override.aes = list(size = 6)))+
  
 # scale_size_continuous(range = c(3, 12)) +
  guides(color = "none") + 
  
  geom_label_repel(
    data = GraphLabs,
    aes(x = longitude, y = latitude, label = Label),
    size = 3,
    nudge_y = 5,
    nudge_x = 0,
    seed = 10,
    max.overlaps = 50,
    label.padding = 0.15,
    label.size = .01,
    label.r = 0.01
  ) +
  theme_void()


BubbleMap
```

------------------------------------------------------------------------

### Part C: Sequencing type

#### Assigning yes-no

Assigning Boolean variables for the sequencing type.

```{r}
BioDIGS_Donut <- BioDIGS_Cleaned %>%
  mutate(
    Pseudo_reads = case_when(
      grepl("yes", short_read, ignore.case = TRUE) & grepl("yes", long_read, ignore.case = TRUE) ~ 1,
      grepl("yes", short_read, ignore.case = TRUE) & grepl("no", long_read, ignore.case = TRUE)  ~ 2,
      grepl("no", short_read, ignore.case = TRUE)  & grepl("yes", long_read, ignore.case = TRUE) ~ 3,
      TRUE ~ NA_real_
    ),
  )

Read_counts <- count(BioDIGS_Donut, Pseudo_reads)
Read_counts$perc <- Read_counts$n/sum(Read_counts$n)
Read_counts$ymax = cumsum(Read_counts$perc)
Read_counts$ymin = c(0, head(Read_counts$ymax, n=-1))

Read_counts$Pseudo_reads <- as.character(Read_counts$Pseudo_reads)
remove(BioDIGS_Donut)
```

#### Plotting

```{r}
Donut_plot<-ggplot(Read_counts, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=Pseudo_reads)) +
  geom_rect() +
  coord_polar(theta="y") + # Try to remove that to understand how the chart is built initially
  xlim(c(2, 4))+theme_void()+
  theme(legend.position="left",
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 12),
        legend.key.size = unit(1, "cm")) +
  scale_fill_manual(
    values = c("1" = "#66c2a5", "2" = "#fc8d62", "3" = "#8da0cb"),
    labels = c("1" = "Both","2" = "Short", "3" = "Long"),
    name = "Read type"
  ) + 
  geom_text(
    label = n
  )

Donut_plot
```

------------------------------------------------------------------------

### Part D: Soil composition

#### Load in the libraries

```{r}
Soil_Makeup <- read_excel(
  "C:/Users/kathe/Downloads/BioDIGS_soil_testing_data.xlsx", 
  sheet = "modified"
  )

head(Soil_Makeup)
```

#### Cleaning the data

Removing "Not yet tested," "NA," "\<," and any white space remaining. Then, converting the element columns to numeric from character.

```{r}
#Removing strings from where we want numeric data
Soil_Makeup <- Soil_Makeup %>%
  mutate(across(
    where(is.character),
    ~ gsub("<", "", na_if(na_if(.x, "Not yet tested"), "NA"))
  )) %>% 
  mutate(across(
    where(is.character),
    ~ trimws(.x, which = "both")
  ))

#Removing any NAs from the previous step  
Soil_Makeup <- na.omit(Soil_Makeup)

#Changing the columns to numeric from character

Soil_Makeup <- Soil_Makeup %>%
  mutate(across(
    2:ncol(Soil_Makeup),
    ~ as.numeric(.x)
  ))
```

Pivoting from wide format to long format. This is the format needed for histograms. Wide format is good for heatmaps.

```{r}
Soil_Long <- Soil_Makeup %>%
  pivot_longer(
    cols = 2:ncol(Soil_Makeup),
    names_to = "Element",
    values_to = "Values"
  )
```

#### Making the histogram

Faceting around the element

```{r}
ggplot(Soil_Long, aes(x=Values)) +
  geom_histogram() +
  facet_wrap("Element", scales = "free")
```
